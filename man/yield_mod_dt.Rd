% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/yield_mod.R
\name{yield_mod_dt}
\alias{yield_mod_dt}
\title{Modifies input data.tables by provided multipliers}
\usage{
yield_mod_dt(inlist, ybetas, code, cropnames, silent = TRUE)
}
\arguments{
\item{inlist}{Named list of input data.tables}

\item{ybetas}{list of either 2 data.tables or 2 vectors providing
modifications for climate & irrigation}

\item{code}{Unique simulation code resulting from run_code function}

\item{cropnames}{Names of simulated crops}

\item{silent}{Hide or show print statements (TRUE [default] or FALSE)}
}
\description{
This is a data.table-based version of this function.
}
\details{
For ybetas, if data.tables are provided, each data.table should
provide one column to represent the impacts to each crop, or a single column
that will apply to all crops. Vectors can alternatively be provided that
apply a uniform yield modification. See further details in documentation
for \code{\link{yield_mod_r}}
}
\examples{
rc <- run_code(input_key = "ZA")
il <- fetch_inputs(input_key = "ZA")  # fetch all necessary inputs
inlist_dt <- raster_list_to_dt(inlist = il[c("p_yield", "pp_curr")])

# no yield modification
ybetas <- list(1, 1)
ybeta <- yield_mod_dt(inlist = inlist_dt[[2]], ybetas = ybetas,
                      code = rc, cropnames = il$cropnames)

# yield modification with vectors
ybetas <- list(rep(0.75, nlayers(il[[3]])), rep(0.75, nlayers(il[[3]])))
ybeta2 <- yield_mod_dt(inlist = inlist_dt[[2]], ybetas = ybetas, code = rc,
                       cropnames = il$cropnames)
ybeta2r <- dt_list_to_raster(inlist_dt[[1]][, c("x", "y"), with = FALSE],
                             ybeta2, projection(il$currprod))
ybeta_r <- yield_mod_r(il[c("p_yield", "pp_curr")], ybetas = ybetas,
                       code = rc, cropnames = il$cropnames)
plot(ybeta2r$y_std - ybeta_r$y_std)  # equal
plot(ybeta2r$p_yield - ybeta_r$p_yield)  # equal
plot(ybeta2r$pp_curr - ybeta_r$pp_curr)  # equal

# yield modification with rasters
# ybetas as rasters
dfact <- c(0.9, 1.2)
ybetas_l <- lapply(1:2, function(x) {
 r <- il[[3]]  # recycling
 r[] <- rnorm(n = ncell(r), mean = dfact[x], sd = 0.05)
 mask(r, il[[3]])
})
ybetas_dt <- raster_list_to_dt(ybetas_l)

ybeta3 <- yield_mod_dt(inlist = inlist_dt[[2]], ybetas = ybetas_dt[[2]],
                       code = rc, cropnames = il$cropnames)
ybeta3r <- dt_list_to_raster(inlist_dt[[1]][, c("x", "y"), with = FALSE],
                             ybeta3, projection(il$currprod))
ybeta_r <- yield_mod_r(inlist = il[c("p_yield", "pp_curr")],
                       ybetas = ybetas_l, code = rc, cropnames = il$cropnames)
plot(ybeta3r$y_std - ybeta_r$y_std)  # equal
plot(ybeta3r$p_yield - ybeta_r$p_yield)  # equal
plot(ybeta3r$pp_curr - ybeta_r$pp_curr)  # equal

# Raster modifier X vector
ybetas_dt[[2]][[2]] <- c(0.9, 0.9)
ybeta4 <- yield_mod_dt(inlist = inlist_dt[[2]], ybetas = ybetas_dt[[2]],
                       code = rc, cropnames = il$cropnames)  # wrong length
ybetas_dt[[2]][[2]] <- c(0.9, 0.9) <- c(1)
ybeta4 <- yield_mod_dt(inlist = inlist_dt[[2]], ybetas = ybetas_dt[[2]],
                       code = rc, cropnames = il$cropnames)  # wrong length
ybetas_dt[[2]][[2]] <- rep(1.25, nlayers(il$currprod))
ybeta5 <- yield_mod_dt(inlist = inlist_dt[[2]], ybetas = ybetas_dt[[2]],
                       code = rc, cropnames = il$cropnames)
ybeta5r <- dt_list_to_raster(inlist_dt[[1]][, c("x", "y"), with = FALSE],
                             ybeta5, projection(il$currprod))
ybetas_l[[2]] <- rep(1.25, nlayers(il$currprod))
ybeta_r <- yield_mod_r(inlist = il[c("p_yield", "pp_curr")],
                       ybetas = ybetas_l, code = rc,
                       cropnames = il$cropnames)
plot(ybeta5r$y_std - ybeta_r$y_std)  # equal
plot(ybeta5r$p_yield - ybeta_r$p_yield)  # equal
plot(ybeta5r$pp_curr - ybeta_r$pp_curr)  # equal
}
\seealso{
\code{\link{yield_mod_r}} for raster-based version
}

