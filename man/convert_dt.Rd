% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/convert_dt.R
\name{convert_dt}
\alias{convert_dt}
\title{Land conversion module}
\usage{
convert_dt(conv_prob, target, crop_frac, pot_yield, cropnames, base, ha,
  keep_index = FALSE)
}
\arguments{
\item{conv_prob}{Conversion probability brick}

\item{crop_frac}{RasterBrick of crop allocation fraction}

\item{pot_yield}{RasterBrick of potential crop yields (modified, if necessary)}

\item{cropnames}{Vector of crop names in analysis}

\item{base}{Name of base data.table that provides grid numbers and coordinates}

\item{keep_index}{FALSE, otherwise valind is retained in the output}

\item{prod_targ}{Production target data.frame}
}
\description{
This module takes inputs from the targets and constraints modules
and determines which pixels are converted. This is an alternate version of
convert, which is relies on data.table functions.
}
\details{
This function relies on vectorization of input rasters to rank pixels
for each crop by their conversion probability, calculate the cumulative
production from most likely to least likely to be converted, and then finding
the pixels which are less than the production target. These are marked as
converted. This function uses the as.data.table.raster function by etiennebr,
the link to which is shown in the note below.
}
\note{
https://gist.github.com/etiennebr/9515738
}
\examples{
# We'll compare both raster and data.table methods here
rc <- run_code(input_key = "ZA")
il <- fetch_inputs(input_key = "ZA")  # fetch all necessary inputs
ybetas <- list(1, 1)
ybeta <- yield_mod_dt(inlist = il[c("p_yield", "pp_curr")], ybetas = ybetas,
                      code = rc, cropnames = il$cropnames)
clist <- list("y_std" = ybeta$y_std, "C" = il$carbon_p, "bd" = il$cons_p,
              "cost" = il$cost)
CRSobj <- projection(raster("external/ext_data/ZA-carbon.tif"))
ha <- res(raster("external/ext_data/ZA-carbon.tif"))[2]^2 / 10000
prod_targ <- c("maize" = 4, "cassava" = 2, "ground" = 2, "cotton" = 2,
               "soy" = 2, "pulse" = 2, "sunflower" = 2, "sugarcane" = 2,
               "wheat" = 2)
target <- targets_dt(prod_targ = prod_targ, currprod = il$currprod,
                     potprod = ybeta$pp_curr)
#targetr <- targets_r(prod_targ, currprod = il$currprod,
                      potprod = ybetar$pp_curr, code = rc,
                      cropnames = il$cropnames)
#identical(target, targetr)

cbetas <- c("y_std" = 0, "C" = 1, "bd" = 1, "cost" = 1)
conv_prob <- constraints_dt(inlist = clist, cbetas = cbetas, code = rc,
                            cropnames = il$cropnames)
valind <- which(values(il$mask) == 1)
system.time(conv <- convert_dt(conv_prob, target = target,
                               crop_frac = il$cropfrac,
                               pot_yield = ybeta$p_yield, valind = valind,
                               cropnames = il$cropnames,
                               base = il$grid, ha = ha))  # 0.135 seconds
system.time(convr <- convert_r(conv_prob = conv_probr2, target = targetr,
                               crop_frac = il$cropfrac,
                               pot_yield = ybetar$p_yield,
                               code = il$code, cropnames = il$cropnames))  # 2.9s
convr2 <- dt_to_raster(dt = conv, CRSobj = projection(il$currprod))
plot(convr - convr2)  # both approaches equal

cbetas <- c("y_std" = 1, "C" = 1, "bd" = 1, "cost" = 0)
conv_prob <- constraints_dt(inlist = clist, cbetas = cbetas, code = rc,
                            cropnames = il$cropnames, base = il$mask)
conv_probr1 <- dt_list_to_raster(base = base, inlist = list(conv_prob),
                                 CRSobj = prj)[[1]]
conv_probr2 <- constraints_r(inlist = clistr, cbetas = cbetas, code = rc,
                             cropnames = il$cropnames)

valind <- which(values(il$mask) == 1)
system.time(conv <- convert_dt(conv_prob, target = target,
                               crop_frac = il$cropfrac,
                               pot_yield = ybeta$p_yield,
                               cropnames = il$cropnames,
                               base = il$mask, ha = ha))  # 0.135 seconds
convr2 <- dt_to_raster(dt = conv, CRSobj = CRSobj)
#plot(convr - convr2)  # both approaches equal
plot(convr2)
}

